#!/bin/bash
# aur2ccr - version 0.6.6
# Pull information from AUR or Arch repos, and make source packages that are ready for uploading to CCR.
# Usage: aur2ccr [OPTIONS] [PACKAGES]
# Todo: see README (https://github.com/redhat69/aur2ccr/README)
# -- CREDITS --
# This script uses the information on converting Arch/AUR files to CCR from http://chakra-linux.org/wiki/index.php/How_to_upload_a_package_to_CCR_when_it_exists_on_Arch_or_Aur
# Portions of this script have been taken from "CCR - A Chakra Community Repository helper", which was in turn forked from "Packer by Matthew Bruenig <matthewbruenig@gmail.com>", a GPL3 bash script.
# Thanks to: 
#  CaptainKnots for the github repo and the original idea behind aur2ccr;
#  Inkane for submitting bug reports, feature requests, and code;
#  abveritas for adding to the arch/chakra package name translations list;
#  tetris4 and [jmc] for their support and help developing the script;
#  the developers of ccr, packer, abs, and the other tools this script uses;
#  the Chakra devs, for making such an awesome distro;
#  ...and all others who have used aur2ccr or helped in some other way.

# internal settings - you can modify some of these in aur2ccr.conf
pname="aur2ccr"         pver="0.6.6"
confdir="/etc/aur2ccr"  lconfdir=~/.aur2ccr # must be unquoted to use ~ substitution
tmpdir="/tmp/aur2ccr"   ltmpdir=~/tmp/aur2ccr
namesconf="names.conf"  apconf="archrepos.pacman.conf"  
acconf="aur2ccr.conf"
# initialize variables
startdir="$(pwd)"       findir="$(pwd)"
badpkgs=0               consolidate=0
edit=0                  addad=0
install=0               archrinit=0
newline=$'\n'           
RED='\e[1;31m'          YELLOW='\e[1;33m'
BLUE='\e[1;34m'         PINK='\e[1;35m'
WHITE='\e[1;37m'        ENDCOLOR='\e[0m'        
programs=( abs autoconf automake bison ccr cmake curl ed flex gawk gcc jshon libtool m4 make makepkg patch pacman getmirrors.sh )

# output formatting functions
debug() { # echo things when called like 'debug doing stuff...' only when debug=1
  pushd "$(pwd)" >/dev/null; cd "$startdir"
  if [[ "$debug" == 1 ]]; then
    if [[ "$1" == "-n" ]]; then
      local eopts="$1"; shift
    fi; ([[ -n "$logfile" ]] && echo -e $eopts "${PINK}++>${ENDCOLOR}" "$@" | tee -a "$logfile") || echo -e $eopts "${PINK}++>${ENDCOLOR}" "$@"
  fi; popd >/dev/null
}

msg() { # make aur2ccr's normal output prettier and more unified.
  debug "msg('$@')"
  pushd "$(pwd)" >/dev/null; cd "$startdir"
  if [[ "$1" == "-n" ]]; then
    local eopts="$1"
    shift
  fi; ([[ -n "$logfile" ]] && echo -e $eopts "${BLUE}==>${ENDCOLOR}" "$@" | tee -a "$logfile") || echo -e $eopts "${BLUE}==>${ENDCOLOR}" "$@" 
  popd >/dev/null
}

warn() { # make aur2ccr's warning messages prettier and more unified.
  debug "warn('$@')"
  pushd "$(pwd)" >/dev/null; cd "$startdir"
  if [[ "$1" == "-n" ]]; then
    local eopts="$1"
    shift
  fi; ([[ -n "$logfile" ]] && echo -e $eopts "${YELLOW}==>${ENDCOLOR}" "$@" | tee -a "$logfile") || echo -e $eopts "${YELLOW}==>${ENDCOLOR}" "$@"
  popd >/dev/null
}

err() { # make aur2ccr's error messages prettier and more unified.
  debug "err('$@')"
  pushd "$(pwd)" >/dev/null; cd "$startdir"
  if [[ "$1" == "-n" ]]; then
    local eopts="$1"
    shift
  fi; ([[ -n "$logfile" ]] && echo -e $eopts "${RED}==> ERROR:${ENDCOLOR}" "$@" | tee -a "$logfile") || echo -e $eopts "${RED}==> ERROR:${ENDCOLOR}" "$@" >&2
  popd >/dev/null
}

# other functions
clean() {  # clean up temp files
  debug "clean('$@')"
  warn "Keyboard interrupt caught, cleaning up..."; debug "exiting..."
  exit 1
}

initarchr() {	# set up the arch repo vars, so we only need to sudo once
  debug "initarchr('$@')"
  if sudo pacman -Sy --config "$paconf"; then
    areplist=$(pacman --config "$paconf" -Ssq)
    afullist=$(pacman --config "$paconf" -Ss)
    archrinit=1
    debug "sudo pacman -Sy ..."
    sudo pacman -Sy >&2> /dev/null
  else
    err "An error occurred while checking Arch repos."
    debug "exiting..."
    exit 1
  fi
}

grepacfull() {  # grep the output of pacman -Ss in a useful manner
  debug "grepacfull('$@')"
  [[ "$archrinit" == 0 ]] && initarchr
  local num=0; local ret=0; IFS=$'\n'; debug "entering 'for' loop..."
  for line in $afullist; do
    if [[ "$num" == 0 ]]; then
      entry="${line}${newline}"
      num=1
    elif [[ "$num" == 1 ]]; then
      entry="${entry}${line}"
      num=0
      echo "$entry" | grep -iq "$1" && (echo "$entry"; export ret=1) # this is slow [avg 45-50s total], we need a better way. would perl be faster?
    fi
  done
  IFS=" "
  [[ "$ret" == 0 ]] && echo " (nothing found)"
}

isoutofdate() {  # stolen from the isoutofdate() and rpcinfo() functions in 'ccr'
  debug "isoutofdate('$@')"
  RPCURL="https://aur.archlinux.org/rpc.php?type"
  [[ -f "$tmpdir/$1.info" ]] || curl -LfGs --data-urlencode "arg=$1" "$RPCURL=info" > "$tmpdir/$1.info"
  [[ "$(jshon -Q -e results -e OutOfDate -u < "$tmpdir/$1.info")" = "1" ]]
}

vcsver() {  # look for version control system versions, like pkgname-git
  debug "vcsver('$@')"
  if isinccr "$1-git"; then # git
    vpkgname="$1-git"
    return 0
  elif isinccr "$1-bzr"; then # bazaar
    vpkgname="$1-bzr"
    return 0
  elif isinccr "$1-svn"; then # subversion
    vpkgname="$1-svn"
    return 0
 elif isinccr "$1-hg"; then # mercurial
    vpkgname="$1-hg"
    return 0
  else
    return 1
  fi
}

isinccr() {  # check in CCR and main repos for package
  debug "isinccr('$@')"
  ccr -Ssq $1 | grep -q "^$1$"
}

isinrepos() {  # check in main Chakra repos for package - stolen from 'ccr'
  debug "isinrepos('$@')"
  pacman -Si -- "$1" &>/dev/null
}

isinaur() {
  debug "isinaur('$@')"
  echo "$1" | grep -q '^..' || (err "Package names must be at least two characters in length"; exit 1) || exit 1 # if the package name is not at least 2 chars, checking aur will fail.
  wget -q --spider "https://aur.archlinux.org/packages/$(echo "$1" | sed 's/\(..\).*/\1/')/$1/PKGBUILD"
}

isinarchr() {
  debug "isinarchr('$@')"
  msg "Checking Arch repos..."
  [[ "$archrinit" == 0 ]] && initarchr
  echo "$areplist" | grep -q "^$1$"  # much nicer than the old function
}

getarchname() {
  debug "getarchname('$@')"
  if isinarchr $1; then
    archname=$(echo "$afullist" | grep -o "^[^ ]*/$1\s" | sed 's/\s//g')
  else
    err "'$1' not found in Arch repos"
  fi
}

depends() {  # get the dependencies from the PKGBUILD - stolen from 'ccr'
  # declare vars from the PKGBUILD as local, so aur2ccr doens't get confused
  local pkgname=; local pkgver=; local pkgrel=; local url=; local arch=; local license=; local source=; local md5sums=; local srcdir=; local pkgdir=; local install= 
  debug "depends($@)"; debug "current dir: $(pwd; ls)"
  . PKGBUILD; IFS=$'\n'
  depends=( $(echo -e "${depends[*]}\n${makedepends[*]}" | sed -e 's/=.*//' -e 's/>.*//' -e 's/<.*//'| sort -u) ); IFS=' '
  debug "depends=( ${depends[@]} )"
}

addmaintainer() {  # change maintainer info in the PKGBUILD
  debug "addmaintainer('$@')"
  sed -i 's/^# Maintainer: /# Contributer: /' PKGBUILD
  (printf "# Maintainer: ${maintainer}\n$(cat PKGBUILD)" > PKGBUILD.1 && mv PKGBUILD.1 PKGBUILD) || return 1
}

addad() {
  debug "addad('$@')"
  ed -s PKGBUILD << EOF && msg "Ad added. Thanks for supporting aur2ccr! :)"
2i
# Contributer: aur2ccr (http://ddg.gg/?q=!ccr+aur2ccr)
.
wq
EOF
}

uchksums() {  # update checksums with 'makepkg -gf'
  debug "uchksums($@)"
  debug "current dir: $(pwd; ls)"
  if makepkg -gf > "$tmpdir/${PID}${UID}.sums"; then
    sums="$(cat "$tmpdir/${PID}${UID}.sums")"
  else
    err "'makepkg -g' failed in '$(pwd)'!"
    return 1
  fi
  stype="$(echo $sums | grep -o "^..*sums=")"
  if echo "$sums" | grep -q "^$stype"; then
    if grep -Pq "(^$stype.*\)|^${stype}[^\(])" PKGBUILD; then # if all on one line
      debug "s/^$stype.*/$sums/"
      sed -i "s/^$stype.*/$sums/" PKGBUILD || (err "sed failed while updating checksums"; exit 1) || return 1
    elif grep -q "^$stype" PKGBUILD; then
      stype="$(echo "$stype" | sed 's/=//; s/\s//g')"
      debug "awking..."
      local new="$(awk -v "newsums=$sums" -v "stype=$stype" '$1 ~ stype { t = 1; } t == 1 { if ($0 ~ "\)") { t = 0; print(newsums); next; } next; } { print; }' PKGBUILD 2>/dev/null)" # sheesh. awk courtesy of pr3d4t0r, I haven't a clue how it works.
      debug "sending awk output to PKGBUILD..."
      echo "$new" > PKGBUILD
    elif [[ -z "$sums" ]]; then
      return 0
    else
      return 1
    fi
  else
    err "something went wrong while updating checksums"
    return 1
  fi
}

optipkg() {  # optimize PKGBUILDs by getting rid of a few easy-to-fix errors, etc - note that this must be run AFTER the unsplitp function, so it does not break split packages.
  debug "optipkg($@)"
  grep -q '^# $Id' PKGBUILD && sed -i '/^# $Id[$:].*$/d' PKGBUILD # get rid of $Id tags, which are not used by CCR.
  grep -q "^[^ ]*=(['\"\s]*)" PKGBUILD && sed -i "/^[^ ]*=(['\"\s]*)/d" PKGBUILD # get rid of empty arrays, like depends=()
  grep -q "^[^ ]*=([^'\"\s][^ ]*[^'\"\s])" PKGBUILD && sed -i "s/\(^[^ ]*=(\)\([^'\"\s][^ ]*[^'\"\s]\)\().*$\)/\1'\2'\3/" PKGBUILD # quote unquoted single values in arrays, like arch=(any)
  grep -q "^package()" PKGBUILD || grep -q "^build()" PKGBUILD && sed -i "/^build()/s//package()/" PKGBUILD # if there is no package() function, but there is a build() function, rename build() to package()
}

isinstalled() { # check if $1 is already installed
  debug "isinstalled('$@')"
  pacman -Qq -- "$1" &>/dev/null
}

getneedeps() { # get the deps we need from CCR, return in $needeps
  debug "getneedeps($@)"
  for dep in "${depends[@]}"; do
    if isinrepos $dep; then
      needeps="$needeps"
    elif isinstalled $dep; then
      needeps="$needeps"
    elif isinccr $dep; then
      needeps="$needeps $dep"
    else
      err "dependency $dep cannot be found!"
      exit 1
    fi
  done
  needeps="$(echo $needeps | sed 's/^\s*//')"
  debug "neepeds='$needeps'"
}

logerr() {  # keep track of errors; $1 is the package name
  debug "logerr('$@')"
  [[ -n "$1" ]] && let badpkgs=$badpkgs+1
  [[ -n "$1" ]] && failedpkgs="$failedpkgs $1"
}

namelookup() {  # see https://github.com/redhat69/aur2ccr/issues/1
  debug "namelookup('$@')"
  if [[ -r "$namesconf" ]]; then
    if grep -q "$1=..*" "$namesconf"; then
      apkgname="$1"
      cpkgname="$(grep "^$1=..*" "$namesconf" | sed "s/$1=//")"
    else
      return 1
    fi
  else 
    return 1
  fi
}

namechange() {  # companion function to namelookup()
  debug "namechange('$@')"
  namelookup $1 && sed -i "s/\(^[^ ]*depends=.*[(\s'\"]\)${apkgname}\([\s'\")]\)/\1${cpkgname}\2/g" PKGBUILD || return 1
}

dotherest() {  # this used to be 150 lines, but I managed to get it down a little bit - it's still too large.
  debug "dotherest('$@')"
  local pkgname=$1
  depsnotinrep=0
  #msg "Checking if this is a split PKGBUILD..."
  #isplitp PKGBUILD && makeccrpkg_s; return 0
  #msg "This doesn't appear to be a split PKGBUILD, continuing..."; msg -n "Checking for and fixing common PKGBUILD problems... "
  #optipkg; echo "done."
  [[ -n "$maintainer" ]] && (msg "Changing maintainer information..."; debug "if addmaintainer \$maintainer, then msg(done), else err(failed)..."; (addmaintainer "$maintainer" && msg "Done" || err "Failed"))
  debug "if \$addad then addad..."
  [[ "$addad" == 1 ]] && addad
  debug "if uchksums..."
  (uchksums && msg "checksums for $pkgname updated") || warn "checksums for $pkgname could not be updated!"
  debug "if \$edit, then edit..."
  [[ "$edit" -eq 1 ]] && (msg "Opening '$pkgname' PKGBUILD with $EDITOR"; warn "Note: dependencies have not yet been checked, so the PKGBUILD"; warn " may be changed after you modify it."; debug "\$EDITOR PKGBUILD"; ${EDITOR-vi} PKGBUILD)
  depends
  debug "for pkg in ${depends[@]}..."
  for pkg in ${depends[@]}; do 
    if [ "$pkg" == "java-environment" -o "$pkg" == "java-runtime" ]; then
      msg "$pkg is a special package in the Chakra repos, continuing"
    elif [[ "$pkg" == "$pkgname" ]]; then
      warn "dependency cycle detected!"; warn "skipping '$pkgname' dependency '$pkg'"
    elif isinccr $pkg; then 
      msg "$pkgname dependency '$pkg' already in CCR or repos, continuing"
      isinrepos $pkg || let depsnotinrep=$depsnotinrep+1
    elif namelookup $pkg; then
      namechange $pkg || (err "Something went wrong while attempting to edit the $pkgname PKGBUILD"; logerr $pkg; exit 1) || return 1
      if isinccr $cpkgname; then
        msg "$pkgname dependency '$apkgname' already in CCR or repos as '$cpkgname', continuing"
        isinrepos $cpkgname || let depsnotinrep=$depsnotinrep+1
      else 
        err "There seems to be a bad definition in '$namesconf'. Please fix this."; err "The offending line is: '$apkgname=$cpkgname'"; logerr $pkg
        return 1
      fi
    else
      let depsnotinrep=$depsnotinrep+1
      msg "$pkgname dependency '$pkg' not in CCR or repos, looking at Arch packages..."
      if isinaur $pkg; then
        debug "pushd `pwd`"
        pushd "$(pwd)" >/dev/null
        (makeccrpkg $pkg && (debug "popd"; popd >/dev/null)) || (err "Some error occurred while building '$pkg'"; err "Without this dependency, $pkgname cannot be built"; debug "popd"; popd >/dev/null; exit 1) || return 1
      elif isinarchr $pkg; then
        msg "'$pkg' found in the Arch repos..."; debug "pushd `pwd`"
        pushd "$(pwd)" >/dev/null
        (makeccrpkg_r $pkg && (debug "popd"; popd >/dev/null)) || (err "Some error occurred while building '$pkg'"; err "Without this dependency, $pkgname cannot be built"; debug "popd"; popd >/dev/null; exit 1) || return 1
      else
        err "Sorry, dependency '$pkg' cannot be found."; err "Without this dependency, $pkgname cannot be built"; logerr $pkg
        return 1
      fi
    fi
  done
  if [[ "$depsnotinrep" -eq 0 ]]; then
    msg "Testing package '$pkgname'..."
    makepkg -sfr || (err "Some error occurred, check the $pkgname PKGBUILD in $(pwd)"; logerr $pkgname; exit 1) || return 1
  else
    msg "Package '$pkgname' has dependencies outside of the Chakra repos."
    msg "Attempting to install dependencies with 'ccr'..."; msg "(This may take a while)"
    getneedeps
    if [[ -z "$needeps" ]]; then
      msg "Oops, looks like you already have all these dependencies installed."
      makepkg -sfr || (err "Some error occurred, check the $pkgname PKGBUILD in $(pwd)"; logerr $pkgname; exit 1) || return 1
    elif ccr -S $needeps; then
      msg "Succeeded, continuing"
      makepkg -sfr || (err "Some error occurred, check the $pkgname PKGBUILD in $(pwd)"; logerr $pkgname; exit 1) || return 1
      if [[ "$install" -eq 0 ]]; then
        msg "Removing packages..."
        (sudo pacman -Rn $needeps && msg "Packages removed") || err "could not remove packages!"
      else
        depsnotinrep=0
      fi
    else
      warn "Package '$pkgname' has dependencies outside of the Chakra repos and CCR."; warn "Running 'makepkg -s' on this package will fail, so we cannot test it now."; warn "Please test the final .src.tar.gz package manually with ccr."
    fi
  fi
  if makepkg --source -f; then
    msg "Package '$pkgname' built successfully."
    if [[ "$consolidate" -eq 1 ]]; then
      pkgpkg="$(ls $pkgname*.src.tar.gz)"
      (mv $pkgpkg "$findir" && msg "$pkgpkg moved to $findir") || (err "$pkgpkg could not be moved to $findir"; logerr $pkgname; exit 1) || return 1
    fi
    if [[ "$install" -eq 1 && "$depsnotinrep" == 0 ]]; then
      msg "Installing $pkgname..."
      if ! sudo pacman -U $(ls *.pkg.tar.xz); then
        warn "pacman failed, trying 'makepkg -i'..."
        makepkg -if || (err "Could not install $pkgname."; exit 1) || return 1
      fi
      (isinstalled $pkgname && msg "$pkgname installed") || (err "Could not install $pkgname."; exit 1) || return 1
    elif [[ "$install" -eq 1 ]]; then
        warn "$pkgname cannot be installed, because it is missing dependencies."
    fi
  else
    err "Some error occurred, check the $pkgname PKGBUILD in '$(pwd)'"
    logerr $pkgname
    return 1
  fi
}

makeccrpkg() {  # grab a package from AUR, and make it into a CCR-ready src package
  debug "makeccrpkg('$@')"
  cd "$startdir"
  local pkgname=$1
  mkdir -p "$pkgname" || (err "cannot create directory '$startdir/$pkgname'"; logerr $pkgname; exit 1) || return 1
  cd "$pkgname"
  [[ -r "$pkgname.tar.gz" ]] && rm "$pkgname.tar.gz"
  wget "https://aur.archlinux.org/packages/$(echo "$pkgname" | sed 's/\(..\).*/\1/')/$pkgname/$pkgname.tar.gz" || (err "There was an error while trying to download the package."; logerr $pkgname; exit 1) || return 1
  (tar -xzf "$pkgname.tar.gz" && rm "$pkgname.tar.gz") || (err "tar could not extract the archive"; logerr $pkgname; exit 1) || return 1
  cd "$pkgname"
  dotherest "$pkgname" || (logerr $pkgname; exit 1) || return 1
}

makeccrpkg_r() {    # grab a package from Arch repos, and make it into a CCR-ready src package
  debug "makeccrpkg_r('$@')"
  cd "$startdir"
  local pkgname=$1
  mkdir -p "$pkgname" || (err "cannot create directory '$startdir/$pkgname'"; logerr $pkgname; exit 1) || return 1
  cd "$pkgname"
  [[ -r "$pkgname.tar.gz" ]] && rm "$pkgname.tar.gz"
  # get Arch package with PKGBUILD, .install, etc, using perl or whatever - extract the package if needed
  getarchname $pkgname
  if [[ -z "$archname" || "$archname" == 0 ]]; then
    err "'$pkgname' cannot be found"; logerr $pkgname
    return 1
  fi; msg "found '$pkgname' as '$archname'"
  if sudo abs "$archname"; then
    rm -rf "./$pkgname"
    if sudo mv "/var/abs/$archname" "./$pkgname"; then
      (sudo chown -hR $USER:$GROUPS "./$pkgname" && msg "$pkgname info retrieved from Arch repos successfully") || (err "chown failed"; logerr $pkgname; exit 1) || return 1
    else
      err "could not move /var/abs/$archname to working dir"; logerr $pkgname
      return 1
    fi
  else
    err "abs failed"; logerr $pkgname
    return 1
  fi  #  ^ this is a quick fix ^
  cd "$pkgname"
  dotherest "$pkgname" || (logerr $pkgname; exit 1) || return 1
}
  
makeccrpkg_u() {  # make a package from a URL
  debug "makeccrpkg_u('$@')"
  cd "$startdir"
  local pkgname="$(basename "$url" | sed 's/\([^\.]\)\..*/\1/')"; local pkgname="${pkgname-$BASHPID}" # if $url is http://example.com/path/package.tar.gz, $pkgname is set to "package".
  local myfile="$(basename "$url")"; local myfile="${myfile-$BASHPID}"
  mkdir -p "$pkgname" || (err "cannot create directory '$startdir/$pkgname'"; logerr $pkgname; exit 1) || return 1
  cd "$pkgname"
  wget -O "$myfile" "$url" || (err "There was an error while trying to download the package"; logerr $pkgname; exit 1) || return 1
  local dir="$(tar -taf "$myfile" | head -1)"
  tar -xaf "$myfile" || (err "tar could not extract the archive"; logerr $pkgname; exit 1) || return 1
  cd "$dir"
  [[ -r PKGBUILD ]] || (err "The package you specified does not seem to be a valid source archive."; logerr $pkgname; exit 1) || return 1
  dotherest "$pkgname" || (logerr $pkgname; exit 1) || return 1
}

makeccrpkg_f() {  # make a package from a *.src.tar.gz file
  debug "makeccrpkg_f('$@')"
  cd "$startdir"
  local pkgname="$(basename "$file" | sed 's/\([^\.]\)\..*/\1/')" # same as in _u above
  local dir="$(tar -taf "$file" | head -1)"
  [[ -r "$file" ]] || (err "'$file' cannot be opened or does not exist"; logerr $pkgname; exit 1) || return 1
  mkdir -p "$pkgname" || (err "cannot create directory '$startdir/$pkgname'"; logerr $pkgname; exit 1) || return 1
  tar -xaf "$file" -C "$pkgname" || (err "tar could not extract the archive"; logerr $pkgname; exit 1) || return 1
  cd "$pkgname/$dir"
  [[ -r PKGBUILD ]] || (err "The package you specified does not seem to be a valid source archive."; logerr $pkgname; exit 1) || return 1
  dotherest "$pkgname" || (logerr $pkgname; exit 1) || return 1
}

makeccrpkg_d() {  # uses $pkgdir as directory containting PKGBUILD. (argument to -d)
  debug "makeccrpkg_d('$@')"
  cd "$startdir"
  local pkgname="$(basename "$pkgdir")"
  [[ -d "$pkgdir" ]] || (err "$pkgdir is not a directory or does not exist"; logerr $pkgname; exit 1) || return 1
  cd "$pkgdir"; [[ -r "PKGBUILD" ]] || (debug "cd: `pwd`"; err "'$pkgdir/PKGBUILD' cannot be opened or does not exist"; logerr $pkgname; exit 1) || return 1
  cd "$startdir"
  mkdir -p "$pkgname" || (err "cannot create directory '$startdir/$pkgname'"; logerr $pkgname; exit 1) || return 1
  if [[ "$pkgdir" != "$pkgname/$pkgname" && "$pkgdir" != "$(pwd)/$pkgname/$pkgname" && "$pkgdir" != "./$pkgname/$pkgname" ]]; then # This is bad
    cp -r "$pkgdir" "$pkgname/" || (err "cannot copy files from '$pkgdir'"; logerr $pkgname; exit 1) || return 1
  fi
  cd "$pkgname/$pkgname"
  dotherest "$pkgname" || (logerr $pkgname; exit 1) || return 1
}

makeccrpkg_s() {  # handle split PKGBUILDs
  echo -n #dummy
}

aursearch() {  # this code is stolen from 'packer'. This used to be, and is the equivalent of: packer --auronly -Ss $1 
  debug "aursearch('$@')" >&2
  RPCURL="https://aur.archlinux.org/rpc.php?type"
  curl -LfGs --data-urlencode "arg=$1" "$RPCURL=search" | sed -e 's/","/"\n"/g' -e 's/\\//g' > "$tmpdir/$1$UID.search" 
  parsefile="$tmpdir/$1$UID.search" IFS=$'\n'
  aurname=( $(grep -F '"Name":"' "$parsefile" | cut -d '"' -f 4) )
  version=( $(grep -F '"Version":"' "$parsefile" | cut -d '"' -f 4) )
  description=( $(grep -F '"Description":"' "$parsefile" | sed -e 's/^"Description":"//' -e 's/"$/ /') )
  aurtotal="${#aurname[@]}"
  for ((i=0 ; i<$aurtotal ; i++)); do
    printf "aur/${aurname[$i]} ${version[$i]}\n    ${description[$i]}\n"
  done
}

pkgsearch() {  # there is no reason for this function to ever be called except right after isinarchr returns 1
  debug "pkgsearch('$@')"
  warn "Package '$1' not found in AUR or Arch repos."; warn "Did you mean: "; debug "checking aursearch..."
  local aurpkgs="$(aursearch $1)"
  ([[ -n "$aurpkgs" ]] && (echo "$aurpkgs"; exit 1)) || (grepacfull $1; exit 1) || exit 1
}

checkaur() {
  debug "checkaur('$@')"
  if isinaur $1; then 
    msg "'$1' found in AUR..."
    if isoutofdate $1; then
      warn "$1 is marked as out of date in AUR!"
      warn -n "Are you sure you want to continue? [y/N] "; read ans
      ([[ -z "$ans" || "$ans" == "n" || "$ans" == "N" || "$ans" == "no" ]] && (warn "Skipping $1"; exit 0)) || (warn "Continuing. This is a bad idea!"; sleep 3)
    fi
    makeccrpkg $1 || logerr $1
  elif isinarchr $1; then
    msg "'$1' found in the Arch repos..."
    makeccrpkg_r $1 || logerr $1
  else
    pkgsearch $1
  fi
}

setup() {  # perform some setup-related stuff interactively
  msg "In order to choose the best mirror, we need to know where you are."
  d_country="$(quiet=1 getmirrors.sh)" d_country="${d_country-Any}"
  msg -n "Please enter your country (leave blank to use '$d_country'): "
  read u_country
  [[ "$u_country" == "" ]] && u_country="$d_country"
  msg "Generating pacman configuration for $paconf..."
  (sudo country="$u_country" apconf="$paconf" getmirrors.sh && msg "Done") || (err "Sorry, something went wrong."; err "Try again with a different country, or make sure you are connected to the internet.")
  exit 0
}

usage() {
  debug "usage('$@')"
  echo "Usage: $(basename $0) [OPTIONS] [PACKAGES]" # is this better than $0?
  echo "Create CCR-ready source packages from packages in AUR or Arch repos"
  echo "Example: $(basename $0) twisted"
  echo 
  echo "General: "
  echo "  -m <maintainer>	add maintainer information to each PKGBUILD before building"
  echo "                	<maintainer> should be in the form 'My Name (nick) <me@example.com>'"
  echo "  -e			edit the PKGBUILD for each package with \$EDITOR before building"
  echo "  -c			move all CCR source packages into the working directory"
  echo "  -i			install packages that build successfully, in order to test them"
  echo
  echo "Advanced: "
  echo "  -f <file>		create a CCR source package from source package <file>"
  echo "  -u <URL>		... or from an AUR/CCR-compatible source package at <URL>"
  echo "  -d <dir>		... or from a PKGBUILD and (optional) other files in <dir>"
  echo "  -C <newdir>		use <newdir> as the working directory instead of the current dir"
  echo "  -t			use '$tmpdir' as the build directory instead of the current dir"
  echo "   			(all finished src packages will be moved into the working dir, like -c)"
  echo "  -l <logfile>		use 'tee' to send all aur2ccr messages to <logfile>"
  echo
  echo "Other: "
  echo "  -s			perform setup-related tasks, such as choosing the best Arch mirror"
  echo "  -a			add an aur2ccr advertisement - add as Contributer: "
  echo "        		'aur2ccr (http://ddg.gg/?q=!ccr+aur2ccr)'"
  echo "  -h			display this help and exit"
  echo "  -v			print version information and exit"
  echo 
  echo "For debugging, use: debug=1 $(basename $0) [OPTIONS] [PACKAGES]"
  echo 
  echo "Note: Options must be specified separately, like '-c -e', not '-ce'."
  echo "This will (hopefully) be fixed in a future version."
  echo 
  echo "Report bugs at: <https://github.com/redhat69/aur2ccr/issues/>"
  echo "aur2ccr home: <https://github.com/redhat69/aur2ccr/>"
  debug "exiting..."
  exit 0
}

popopts() {  # populate variables, enumerate options and arguments -- crappy - if you have a better way, *please* tell me
  debug "popopts('$@')"
  for arg in "$@"; do 
    if [ -n "$isfile" -a "$isfile" == 1 ]; then
      file="$arg"
      isfile=0
      continue
    elif [ -n "$isurl" -a "$isurl" == 1 ]; then 
      url="$arg"
      isurl=0
      continue
    elif [ -n "$isdir" -a "$isdir" == 1 ]; then 
      pkgdir="$arg"
      isdir=0
      continue
    elif [ -n "$iscdir" -a "$iscdir" == 1 ]; then 
      startdir="$arg"
      findir="$arg"
      iscdir=0
      continue
    elif [ -n "$islfile" -a "$islfile" == 1 ]; then 
      logfile="$arg"
      touch "$logfile" >&2> /dev/null
      if ! test -w "$logfile"; then
        err "specified log file '$logfile' is not writable"
        exit 1
      fi
      echo >> "$logfile"
      echo "+++++  aur2ccr logfile, started $(date)  +++++" >> "$logfile"
      echo >> "$logfile"
      islfile=0
      continue
    elif [ -n "$ismaint" -a "$ismaint" == 1 ]; then
      maintainer="$arg"
      ismaint=0
      continue
    fi
    if [ -n "$arg" -a "$arg" == "-m" ]; then
      ismaint=1
    elif [ -n "$arg" -a "$arg" == "-e" ]; then
      edit=1
    elif [ -n "$arg" -a "$arg" == "-c" ]; then
      consolidate=1
    elif [ -n "$arg" -a "$arg" == "-f" ]; then
      isfile=1
    elif [ -n "$arg" -a "$arg" == "-u" ]; then
      isurl=1
    elif [ -n "$arg" -a "$arg" == "-d" ]; then
      isdir=1
    elif [ -n "$arg" -a "$arg" == "-C" ]; then
      iscdir=1
    elif [ -n "$arg" -a "$arg" == "-t" ]; then
      usetdir=1
      consolidate=1
    elif [ -n "$arg" -a "$arg" == "-l" ]; then
      islfile=1
    elif [ -n "$arg" -a "$arg" == "-i" ]; then
      install=1
    elif [ -n "$arg" -a "$arg" == "-s" ]; then
      setup
    elif [ -n "$arg" -a "$arg" == "-h" ]; then
      usage
    elif [ -n "$arg" -a "$arg" == "-v" ]; then
      echo "$pname $pver"
      exit 0
    elif [ -n "$arg" -a "$arg" == "-a" ]; then
      addad=1
    else
      args="$args $arg"
    fi
  done
  if [ -n "$usetdir" -a "$usetdir" == 1 ]; then
    startdir="$tmpdir"
  fi
  if [ -z "$args" -a -z "$url" -a -z "$file" -a -z "$pkgdir" ]; then 
    err "You did not specify any packages to build"
    err "There is nothing to do. Exiting..."
    exit 1
  fi
}

# main()
debug "main('$@')"
# prevent running the script as root
([[ $EUID -eq 0 ]] && (err "This script must not be run as root!"; err "aur2ccr will ask for your password if needed."; \
  err "Exiting..."; debug "script run as root, exiting"; exit 0) && exit 0) && exit 1
# test for important programs that may not be installed 
for bin in ${programs[@]}; do
  debug "checking for $bin..."
  if [[ -x "$(which $bin 2>/dev/null)" ]]; then
    debug " found"
    continue
  else
    debug " not found"; err "Sorry, you need '$bin' to use this script."; err "Try running 'sudo pacman -Sy abs base-devel ccr cmake curl gawk jshon sed'"
    exit 1
  fi
done

# load setting from config files, prefer local over global
if [[ -r "$confdir/$acconf" ]]; then
  debug "found global conf, using"
  . "$confdir/$acconf"
fi; if [[ -r "$lconfdir/$acconf" ]]; then
  debug "found local conf, using"
  . "$lconfdir/$acconf"
fi # if none exist, just use default values
mkdir -p "$tmpdir" || (err "tmpdir '$tmpdir' is a file!"; exit 1) || exit 1 # make the temp dir, if it does not already exist
# find other config files, and set variables to point to them- prefer global over local
if [[ -r "$confdir/$apconf" ]]; then
  debug "found global pacman conf, using"
  paconf="$confdir/$apconf"
elif [[ -r "$lconfdir/$apconf" ]]; then
  debug "found local pacman conf, using"
  paconf="$lconfdir/$apconf"
else 
  debug "could not find local or global pacman conf, using $tmpdir/pacman.conf.tmp instead"
  printf '[community]\nServer = http://ftp.osuosl.org/pub/archlinux/$repo/os/i686\n\n[core]\nServer = http://ftp.osuosl.org/pub/archlinux/$repo/os/i686\n\n[extra]\nServer = http://ftp.osuosl.org/pub/archlinux/$repo/os/i686\n\n[multilib]\nServer = http://ftp.osuosl.org/pub/archlinux/$repo/os/x86_64\n' > "$tmpdir/pacman.conf.tmp"
  paconf="$tmpdir/pacman.conf.tmp"
fi; if [[ -r "$confdir/$namesconf" ]]; then
  debug "found global names.conf, using"
  namesconf="$confdir/$namesconf"
elif [[ -r "$lconfdir/$namesconf" ]]; then
  debug "found local names.conf, using"
  namesconf="$lconfdir/$namesconf"
fi
# fix empty/unset variables to prevent errors
pname="${pname-aur2ccr}"                 pver="${pver-0.7}"
confdir="${confdir-/etc/aur2ccr}"        lconfdir="${lconfdir-~/.aur2ccr}" 
tmpdir="${tmpdir-/tmp}"                  namesconf="${namesconf-names.conf}"
apconf="${apconf-archrepos.pacman.conf}" acconf="${acconf-aur2ccr.conf}" 
startdir="${startdir-$(pwd)}"            findir="${findir-$(pwd)}" 
consolidate="${consolidate-0}"           edit="${edit-0}" addad="${addad-0}" 
[[ -z "$1" || "$1" == "--help" || "$1" == "-h" ]] && usage
popopts "$@"
debug "setting trap"; trap clean INT  # trap keyboard interrupts (^C), in order to clean up temp files
debug "entering 'for' loop"
for pkgname in $args; do
  debug "checking $pkgname"
  if isinccr $pkgname; then
    msg "$pkgname is already in CCR or main Chakra repos."
    msg -n "Continue anyway? [y/N] "
    read ans
    if [[ -z "$ans" || "$ans" == "n" || "$ans" == "N" || "$ans" == "no" ]]; then 
      warn "Skipping $pkgname"; continue
    else 
      checkaur $pkgname
    fi
  elif namelookup $pkgname; then
    msg "$apkgname is already in CCR or main Chakra repos as $cpkgname."
    msg -n "Continue anyway? [y/N] "; read ans
    if [ -z "$ans" -o "$ans" == "n" -o "$ans" == "N" -o "$ans" == "no" ]; then 
      warn "Skipping $pkgname"; continue
    else 
      checkaur $pkgname
    fi
  elif vcsver $pkgname; then
    msg "$pkgname is already in CCR or main Chakra repos as $vpkgname."
    msg -n "Continue anyway? [y/N] "; read ans
    if [[ -z "$ans" || "$ans" == "n" || "$ans" == "N" || "$ans" == "no" ]]; then 
      warn "Skipping $pkgname"; continue
    else 
      checkaur $pkgname
    fi
  else
    checkaur $pkgname
  fi
done
[[ -n "$url" ]] && makeccrpkg_u || logerr $url
[[ -n "$file" ]] && makeccrpkg_f || logerr $file
[[ -n "$pkgdir" ]] && makeccrpkg_d || logerr $pkgdir
# finish up
if [[ "$badpkgs" -gt 0 ]]; then
  err "$badpkgs package(s) failed"
  debug "at least $badpkgs packages failed..."
else
  msg "$badpkgs package(s) failed"; debug "0 pkgs failed, exiting..."
  warn "Remember, just because aur2ccr seems to have succeeded, does not mean the package(s)"
  warn "will work. Please thoroughly test all packages BEFORE uploading them to CCR."
  warn "Broken packages may be removed without warning."
  exit 0
fi
([[ -n "$failedpkgs" ]] && (err "The bad package(s) are:"; err "$failedpkgs"; debug "exiting..."; exit 1)) || exit 0
